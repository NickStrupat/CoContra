<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using System;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;

namespace CoContra {
<#
	for (var i = 0; i != 17; i++) {
		var suffixes = Enumerable.Range(0, i).Select(x => i == 1 ? "" : (x + 1).ToString());
		var types = suffixes.Select(x => "T" + x);
		var typeArgs = String.Join(", ", types.Concat(new [] { "TResult" }));
		var invokeParams = String.Join(", ", suffixes.Select(x => "T" + x + " arg" + x));
		var invokeArgs = String.Join(", ", suffixes.Select(x => "arg" + x));
#>
	public sealed class CoContravariantFunc<<#= typeArgs #>> : CoContravariantDelegateBase<Func<<#= typeArgs #>>, CoContravariantFunc<<#= typeArgs #>>> {
		public CoContravariantFunc() : base() {}
		public CoContravariantFunc(Func<<#= typeArgs #>> func) : base(func.CheckNull(nameof(func))) {}
		public static implicit operator CoContravariantFunc<<#= typeArgs #>>(Func<<#= typeArgs #>> func) => TryUnwrapDelegate(func.CheckNull(nameof(func)).GetMethodInfo(), func.Target) ?? new CoContravariantFunc<<#= typeArgs #>>(func);
		public static implicit operator Func<<#= typeArgs #>>(CoContravariantFunc<<#= typeArgs #>> cfunc) => cfunc.CheckNull(nameof(cfunc)).Invoke;
		public static CoContravariantFunc<<#= typeArgs #>> operator +(CoContravariantFunc<<#= typeArgs #>> ccf, Func<<#= typeArgs #>> func) => Combine(ccf, func);
		public static CoContravariantFunc<<#= typeArgs #>> operator -(CoContravariantFunc<<#= typeArgs #>> ccf, Func<<#= typeArgs #>> func) => Remove(ccf, func);
		public static Boolean operator ==(CoContravariantFunc<<#= typeArgs #>> left, CoContravariantFunc<<#= typeArgs #>> right) => (left?.Equals(right)).GetValueOrDefault();
		public static Boolean operator !=(CoContravariantFunc<<#= typeArgs #>> left, CoContravariantFunc<<#= typeArgs #>> right) => !(left == right);
		
		public override Object Target => GetInvocationList().LastOrDefault()?.Target;
		
#if NET4 || NET45
		public override MethodInfo Method => GetInvocationList().LastOrDefault()?.Method;
#endif
#if !NET4
		public override MethodInfo GetMethodInfo() => GetInvocationList().LastOrDefault()?.GetMethodInfo();
#endif

		public TResult Invoke(<#= invokeParams #>) {
			var array = GetInvocationList();
			var result = default(TResult);
			for (var i = 0; i < array.Length; i++)
				result = array[i].Invoke(<#= invokeArgs #>);
			return result;
		}

#if NET4
		public Task<TResult> InvokeAsync(<#= invokeParams + (invokeParams.Length == 0 ? "" : ", ") #>CancellationToken cancellationToken = default(CancellationToken)) => Task.Factory.StartNew(() => Invoke(<#= invokeArgs #>), cancellationToken);
#else
		public Task<TResult> InvokeAsync(<#= invokeParams + (invokeParams.Length == 0 ? "" : ", ") #>CancellationToken cancellationToken = default(CancellationToken)) => Task.Run(() => Invoke(<#= invokeArgs #>), cancellationToken);
#endif

		public IAsyncResult BeginInvoke(<#= invokeParams + (invokeParams.Length == 0 ? "" : ", ") #>AsyncCallback callback, Object state) {
			var task = InvokeAsync(<#= invokeArgs #>);
			var tcs = new TaskCompletionSource<TResult>(state);
			task.ContinueWith(t => {
				if (t.IsFaulted)
					tcs.TrySetException(t.Exception.InnerExceptions);
				else if (t.IsCanceled)
					tcs.TrySetCanceled();
				else
					tcs.TrySetResult(t.Result);
				callback?.Invoke(tcs.Task);
			}, TaskScheduler.Default);
			return tcs.Task;
		}

		public TResult EndInvoke(IAsyncResult asyncResult) => ((Task<TResult>) asyncResult).Result;

		public override Object DynamicInvoke(params Object[] args) {
			var array = GetInvocationList();
			var result = default(Object);
			for (var i = 0; i < array.Length; i++)
				result = array[i].DynamicInvoke(args);
			return result;
		}
	}

<# } #>
}