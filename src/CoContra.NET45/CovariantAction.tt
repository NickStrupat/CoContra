<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using System;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;

namespace CoContra {
<#
	for (var i = 1; i != 17; i++) {
		var suffixes = Enumerable.Range(0, i).Select(x => i == 1 ? "" : (x + 1).ToString());
		var types = suffixes.Select(x => "T" + x);
		var typeArgs = String.Join(", ", types);
		var invokeParams = String.Join(", ", suffixes.Select(x => "T" + x + " arg" + x));
		var invokeArgs = String.Join(", ", suffixes.Select(x => "arg" + x));
#>
	public sealed class CovariantAction<<#= typeArgs #>> : CoContravariantDelegateBase<Action<<#= typeArgs #>>, CovariantAction<<#= typeArgs #>>> {
		public CovariantAction() : base() {}
		public CovariantAction(Action<<#= typeArgs #>> action) : base(action) {}
		public static implicit operator CovariantAction<<#= typeArgs #>>(Action<<#= typeArgs #>> action) { return new CovariantAction<<#= typeArgs #>>(action); }
		public static implicit operator Action<<#= typeArgs #>>(CovariantAction<<#= typeArgs #>> caction) { return caction.Invoke; }
		public static CovariantAction<<#= typeArgs #>> operator +(CovariantAction<<#= typeArgs #>> cf, Action<<#= typeArgs #>> action) { cf.Add(action); return cf; }
		public static CovariantAction<<#= typeArgs #>> operator -(CovariantAction<<#= typeArgs #>> cf, Action<<#= typeArgs #>> action) { cf.Remove(action); return cf; }
		public static Boolean operator ==(CovariantAction<<#= typeArgs #>> left, CovariantAction<<#= typeArgs #>> right) => left?.GetInvocationList() == right?.GetInvocationList();
		public static Boolean operator !=(CovariantAction<<#= typeArgs #>> left, CovariantAction<<#= typeArgs #>> right) => left?.GetInvocationList() != right?.GetInvocationList();
		
		public Object Target => GetInvocationList().LastOrDefault()?.Target;
		
#if NET4 || NET45
		public MethodInfo Method => GetInvocationList().LastOrDefault()?.Method;
#endif
#if !NET4
		public MethodInfo GetMethodInfo() => GetInvocationList().LastOrDefault()?.GetMethodInfo();
#endif

		public void Invoke(<#= invokeParams #>) {
			var array = GetInvocationList();
			for (var i = 0; i < array.Length; i++)
				array[i].Invoke(<#= invokeArgs #>);
		}

#if NET4
		public Task InvokeAsync(<#= invokeParams + (invokeParams.Length == 0 ? "" : ", ") #>CancellationToken cancellationToken = default(CancellationToken)) => Task.Factory.StartNew(() => Invoke(<#= invokeArgs #>), cancellationToken);
#else
		public Task InvokeAsync(<#= invokeParams + (invokeParams.Length == 0 ? "" : ", ") #>CancellationToken cancellationToken = default(CancellationToken)) => Task.Run(() => Invoke(<#= invokeArgs #>), cancellationToken);
#endif

		public IAsyncResult BeginInvoke(<#= invokeParams + (invokeParams.Length == 0 ? "" : ", ") #>AsyncCallback callback, Object state) {
			var task = InvokeAsync(<#= invokeArgs #>);
			var tcs = new TaskCompletionSource<Boolean>(state);
			task.ContinueWith(t => {
				if (t.IsFaulted)
					tcs.TrySetException(t.Exception.InnerExceptions);
				else if (t.IsCanceled)
					tcs.TrySetCanceled();
				else {
					t.Wait();
					tcs.TrySetResult(true);
				}
				callback?.Invoke(tcs.Task);
			}, TaskScheduler.Default);
			return tcs.Task;
		}

		public void EndInvoke(IAsyncResult asyncResult) => ((Task) asyncResult).Wait();

		public override Object DynamicInvoke(params Object[] args) {
			var array = GetInvocationList();
			var result = default(Object);
			for (var i = 0; i < array.Length; i++)
				result = array[i].DynamicInvoke(args);
			return result;
		}
	}

<# } #>
}